It sounds like your bookmark feature works the first time but stops working when navigating between pages on your **Next.js** app. This often happens due to issues with state management, API calls, or React Query caching.

Here’s a structured approach to fix it:

---

## ✅ **Solution 1: Ensure Correct State Management with React Query**
- If you're using **React Query** to manage bookmarks, ensure the query data is properly invalidated and refetched when a bookmark is added or removed.
  
### **Fix: Invalidate and Refetch Data on Bookmark Change**
```javascript
import { useQuery, useQueryClient, useMutation } from "@tanstack/react-query";

const queryClient = useQueryClient();

// Fetch bookmarks
const { data: favorites = [], isLoading } = useQuery({
  queryKey: ['/api/user/favorites'],
  queryFn: async () => {
    const response = await fetch('/api/user/favorites');
    if (!response.ok) throw new Error('Failed to fetch favorites');
    return response.json();
  }
});

// Mutation for adding/removing bookmarks
const { mutate } = useMutation({
  mutationFn: async ({ verseId, action }) => {
    const response = await fetch(`/api/user/favorites/${verseId}`, {
      method: action === 'add' ? 'POST' : 'DELETE'
    });
    if (!response.ok) throw new Error('Failed to update bookmark');
    return response.json();
  },
  onSuccess: () => {
    queryClient.invalidateQueries(['/api/user/favorites']);
  }
});

// Handle bookmark change
const handleBookmarkChange = (verseId, isBookmarked) => {
  mutate({ verseId, action: isBookmarked ? 'delete' : 'add' });
};
```

### ✅ **Explanation:**  
- **useMutation**: Manages API requests for adding/removing bookmarks.  
- **onSuccess**: Ensures the cache is invalidated and refetched using `queryClient.invalidateQueries`.  
- **queryKey**: Ensures correct data fetching by associating the query to `/api/user/favorites`.  

---

## ✅ **Solution 2: Persist Bookmarks Across Pages**
- If bookmarks disappear after page changes, ensure `cacheTime` and `staleTime` are configured to prevent unnecessary refetching.

### **Fix: Add Caching Configuration**
```javascript
const { data: favorites = [], isLoading } = useQuery({
  queryKey: ['/api/user/favorites'],
  queryFn: async () => {
    const response = await fetch('/api/user/favorites');
    if (!response.ok) throw new Error('Failed to fetch favorites');
    return response.json();
  },
  staleTime: 5 * 60 * 1000, // 5 minutes
  cacheTime: 10 * 60 * 1000 // 10 minutes
});
```
- **staleTime**: Prevents refetching if data is considered "fresh" for 5 minutes.  
- **cacheTime**: Keeps data in cache for 10 minutes even if not used.

---

## ✅ **Solution 3: Prevent Bookmark State Loss on Navigation**
- **Next.js** uses client-side routing with `Link`. Ensure bookmarks persist by keeping state using **Context API** or **React Query**.

### **Fix: Use Context API for Bookmark State**
If you want bookmarks to stay visible without always hitting the API:
```javascript
import { createContext, useContext, useState } from 'react';

const BookmarkContext = createContext();

export const BookmarkProvider = ({ children }) => {
  const [bookmarks, setBookmarks] = useState([]);

  const addBookmark = (verse) => {
    setBookmarks((prev) => [...prev, verse]);
  };

  const removeBookmark = (verseId) => {
    setBookmarks((prev) => prev.filter((verse) => verse.id !== verseId));
  };

  return (
    <BookmarkContext.Provider value={{ bookmarks, addBookmark, removeBookmark }}>
      {children}
    </BookmarkContext.Provider>
  );
};

export const useBookmarks = () => useContext(BookmarkContext);
```

Then wrap your app in `_app.js`:
```javascript
import { BookmarkProvider } from '@/contexts/BookmarkContext';

function MyApp({ Component, pageProps }) {
  return (
    <BookmarkProvider>
      <Component {...pageProps} />
    </BookmarkProvider>
  );
}

export default MyApp;
```

---

## ✅ **Solution 4: Check API Response and Handle Errors**
If bookmarks aren't persisting, ensure your API is correctly processing requests.

- Check API logs for errors.  
- Confirm API response returns the correct bookmark data.  
- Add error handling in your frontend:
```javascript
.catch((error) => {
  console.error('Error:', error.message);
  alert('Failed to update bookmarks. Please try again.');
});
```

---

## ✅ **Solution 5: Additional Tips**
1. **Clear Cache**: If changes don’t apply, clear your React Query cache using:
```javascript
queryClient.invalidateQueries(['/api/user/favorites']);
```

2. **Network Debugging**: Check the Network tab in DevTools to ensure API requests are sent and received correctly.

3. **Local Storage Fallback**: If the API fails, consider storing temporary bookmarks in **localStorage** for a smoother user experience.

---

Try these solutions and let me know if you'd like further adjustments!